# Computational Linguistics Final Project: Algorithmic Music Generation

## Project Description
Just as Natural Language Processing (NLP) models predict the next word in a sentence based on context, this Java project predicts the next musical note based on melodic history.

I use various trigram-based algorithms to generate melodies based on an excerpt I transcribed from Oscar Peterson's "C Jam Blues".

## How to Use

### Compilation
Compile all Java files in the `src` directory:
```bash
javac src/*.java
```

### Running the Generator
Run the main program from the root directory. The program will automatically run all 5 generation algorithms and save the results to the `output/` directory.

```bash
java -cp . src.Main
```

### Output
The program generates files in the `output/` directory:
*   `melody.mid`: The MIDI file of the original input melody (for comparison).
*   `generated_melody_*.txt`: The raw text representation of the melody for each algorithm.
*   `generated_melody_*.mid`: The MIDI file which can be played by converting it to an MP3 online.
*   `trigrams.txt`: Statistical data about the different trigram frequency maps of the different algorithms.

## Project Structure

The project is organized into the following directories:

### `data/`
Contains the input training data.
*   `melody.txt`: The source melody (Oscar Peterson's "C Jam Blues") represented in the custom text format. It includes chord symbols (e.g., `| C7`) and notes (e.g., `c5:4`).

### `output/`
Contains all artifacts generated by the program.
*   `melody.mid`: A MIDI conversion of the input `melody.txt` file.
*   `generated_melody_[algorithm].txt`: The raw text output of a specific generation algorithm.
*   `generated_melody_[algorithm].mid`: The playable MIDI version of the generated melody.
*   `trigrams.txt`: A text file containing detailed statistics about the learned probability matrices.

### `src/`
Contains the Java source code for the application.

*   **`Main.java`**: The entry point. Orchestrates the process: parsing input, running algorithms, and saving results.
*   **`TrigramBuilder.java`**: Responsible for "learning". Parses input and builds N-Gram frequency maps (Markov Chains).
*   **`MelodyGenerator.java`**: The creative engine. Uses frequency maps to probabilistically generate new notes.
*   **`MidiWriter.java`**: Utility to convert custom text format into standard MIDI files.
*   **`MusicUtils.java`**: Helper library for music theory operations (note-to-MIDI, duration math, etc.).

## Computational Linguistics Concepts

### 1. N-Grams and Markov Chains
The core engine of the generator is a **Trigram Model**. In linguistics, a trigram model predicts the probability of a word appearing given the previous two words.

I build a frequency map from the input text and calculate the probability distribution of every possible next note from every unique sequence of two preceding notes. This allows the generator to pick up on melodic and rhythmic patterns in the original melody.

### 2. Tokenization
The input music is "tokenized" into a custom string format: `[pitch][octave]:[rhythm]` (e.g., `c5:4` represents a C note in the 5th octave with a quarter-note duration).

Rests are treated as special tokens (`r:4`), functioning like punctuation or pauses in speech.

### 3. Syntax
Language has syntactic rules (grammar). Music has rhythmic rules (meter).

The generator enforces a "grammar" where every measure must sum to exactly 4 beats. If a generated "sentence" (measure) is incomplete, the model continues generating until the syntactic requirement is met.

## Algorithm Details

### 1. Standard Algorithm (Exact Match)
*   **How it works**: Direct application of the Trigram model. Treats "c5:4" as a unique token.
*   **Pros**: Captures exact style and specific riffs.
*   **Cons**: Rigid. Struggles to adapt to new chord progressions; can only play notes exactly as seen in training.

### 2. Octave-Ignorant Algorithm
*   **How it works**: Separates "Pitch Class" (C, D, E) from "Octave" (3, 4, 5). Learns transitions between pitch classes, then assigns an octave that minimizes distance from the previous note.
*   **Pros**: More flexible; generates variations in different registers.
*   **Cons**: Can sometimes result in disjointed jumps if octave selection logic fails.

### 3. Relative Scale Degree Algorithm (The "Smart" One)
*   **How it works**: Learns the *relationship* between the note and the current chord (e.g., "Major 3rd" instead of "E").
*   **Pros**: Most musical. Allows the melody to "follow the changes" of a new chord progression.
*   **Cons**: Requires a known chord progression for input and output.

### 4. Separated Rhythm & Pitch Algorithm
*   **How it works**: Decouples rhythm from melody. Learns rhythm sequences and pitch sequences independently, then merges them.
*   **Pros**: Creates the most novel results.
*   **Cons**: Can lose the specific "hook" or feel of the original melody.

### 5. Separated Rhythm & Pitch (Octave-Ignorant)
*   **How it works**: Hybrid approach. Generates rhythm separately, generates pitch classes (ignoring octave), then combines them and assigns best-fit octaves.
*   **Pros**: Novel combinations with smoother melodic contours than the standard separated algorithm.
*   **Cons**: Can still lose specific motifs.

## Statistical Analysis of Generated Models
The `trigrams.txt` file provides insight into the variance and predictability of the algorithms.

### 1. Complexity vs. Predictability
We measure complexity by the **Average options for third note** (how many choices the generator has given the previous two).
*   **Standard Algorithm**: `1.37` options. Very deterministic; mostly memorizes the song.
*   **Octave-Ignorant**: `1.75` options. Finding patterns across octaves gives more choices.
*   **Relative Scale Degree**: `1.79` options. Analyzing intervals reveals even more common patterns.
*   **Separated Pitch (Octave-Ignorant)**: `2.06` options. Highest variance; stripping rhythm and octave finds the most connections.

### 2. The "Rhythm" Model
Analysis of the Jazz Blues source material shows:
*   **Bigram with most options**: `8 8` (two eighth notes) is followed by `8` (another eighth note) 193 times, but by `4` (quarter note) only 16 times. This reflects the heavy use of continuous eighth-note runs.

### 3. Sparsity of the Matrix
*   **Standard Model**: 93% sparse (only 168 of 2401 combinations appear).
*   **Octave-Ignorant Model**: 81% sparse.
*   **Conclusion**: Abstracting data (removing octave, using relative pitch) makes the matrix "denser," improving generalization.

## Relationship to Previous Work
This project is based on a "Text Generator" assignment which generated random sentences using trigrams.

### Reused & Adapted Core Logic
*   **`computeFrequencies`**: Adapted to map musical tokens instead of words. Overloaded for different modes (Octave Ignorant, Relative).
*   **`getNextWord`**: The stochastic engine remains largely the same.
*   **`generateText`**: Adapted to generate melodies of specific duration (beats/measures) instead of sentence length.

### Key Differences & Innovations
1.  **Data Structure**: "Words" are now complex "Notes" (Pitch + Duration).
2.  **Context Awareness**: The generator is aware of the underlying **Chord Progression**.
3.  **Separation of Concerns**: Algorithms split Rhythm and Pitch generation.
4.  **Output**: Converts text to MIDI for immediate playback.

